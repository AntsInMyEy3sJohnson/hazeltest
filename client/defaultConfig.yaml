chaosMonkeys:
  # Kills Hazelcast members. As of Feb. 2023/v0.8.0 of Hazeltest, the member killer monkey
  # can only target members running in a Kubernetes cluster, but you can choose between an
  # in-cluster access mode and an out-of-cluster access mode, see below.
  memberKiller:
    # Enables or disables the member killer monkey.
    enabled: false
    # Configures the number of runs or iterations the monkey will perform. Note that
    # number of runs != number of kills in case the chaos probability is set to something
    # less than 1.0 (100%), but the number evaluated to decide whether the monkey should
    # terminate is indeed the number of runs, and not the number of kills.
    numRuns: 100
    # In each run, the monkey will strike with this probability. The provided number expresses
    # a percentage, i.e. 1.0 corresponds to 100%. For this value to be semantically correct,
    # therefore, it must be within the closed interval [0,1].
    chaosProbability: 0.5
    memberAccess:
      # Can take the value of one of its immediate object-type sub-keys, i.e. 'k8sOutOfCluster' or 'k8sInCluster'
      mode: k8sInCluster
      # Controls whether the member killer monkey should only consider active ("ready") members. If this is set to
      # true, the monkey will not kill Pods that haven't achieved readiness.
      targetOnlyActive: true
      # Mode for accessing Hazelcast members from outside the Kubernetes cluster. To connect to the Kubernetes cluster,
      # a kubeconfig file is used.
      # Handy when testing Hazeltest configurations locally prior to a deployment via Helm. However, since the absolute
      # path to the kubeconfig file can be specified by means of the corresponding property (see below), it might also
      # be used for in-cluster access by mounting the kubeconfig file into the Hazeltest Pod and specifying the path
      # accordingly.
      k8sOutOfCluster:
        # Specifies the absolute path to the kubeconfig file to be used to connect to the Kubernetes cluster
        # the target Hazelcast members run on.
        # If 'default' is given, Hazeltest will look for the Kubeconfig in $HOME/.kube/config.
        # In non-default cases, the absolute path of the file to be used can be specified.
        kubeconfig: default
        # The namespace in which to search for Hazelcast member Pods.
        namespace: hazelcastplatform
        # The label selector to use for identifying the Hazelcast member Pods.
        labelSelector: app.kubernetes.io/name=hazelcastimdg
      # Mode for accessing Hazelcast members from within the Kubernetes cluster. Useful when Hazeltest itself gets
      # deployed to Kubernetes because, while member access can be achieved with out-of-cluster mode in combination
      # with mounting the kubeconfig file and specifying its path accordingly, the in-cluster mode only relies on
      # native Kubernetes RBAC artifacts to delete Hazelcast member Pods.
      # (Note that for those artifacts to be rendered by the Helm chart, the 'features.useDeletePodsServiceAccount'
      # property in the chart's values.yaml file has to be set to 'true'.)
      # Hazeltest will attempt retrieve its current namespace by means of the POD_NAMESPACE environment variable and
      # the '/var/run/secrets/kubernetes.io/serviceaccount/namespace' file mounted into the Pod by Kubernetes. If the
      # namespace cannot be retrieved by these means, the monkey will report an error and terminate.
      # Please note that the implication of this is that, regardless of how the namespace is retrieved, the Hazeltest
      # Pod has to reside in the same namespace as the Hazelcast member Pods to be acted upon, i.e. cross-namespace
      # actions on Hazelcast member Pods are not supported.
      k8sInCluster:
        # Same as for out-of-cluster config.
        labelSelector: app.kubernetes.io/name=hazelcastimdg
    # Configures the monkey's sleep behavior for between runs.
    sleep:
      # Whether a sleep should be performed between runs.
      enabled: true
      # The duration, in seconds, to sleep. (Mind the difference between this sleep config's duration and the various
      # runner's sleeps, where the sleep is configured in milliseconds.)
      durationSeconds: 60
      # Enables or disables randomness for this sleep configuration. If enabled, the amount of seconds to sleep will be
      # determined randomly in the closed interval [0, <durationSeconds>]. If disabled, the sleep will be static, i.e.
      # the monkey will simply sleep for the given amount of seconds.
      enableRandomness: false
    # Configures deletion behavior. When enabled, the member killer monkey will kill the selected Hazelcast member
    # using a grace period as defined by 'durationSeconds' and 'enableRandomness'.
    memberGrace:
      # Whether members should be terminated gracefully at all.
      enabled: true
      # Number of seconds for the graceful shutdown, if member grace has been enabled. Randomness can be enabled for
      # this, however, see below.
      durationSeconds: 30
      # Activates or deactivates randomness for the 'durationSeconds' property. The rules are the same as for the
      # sleep configuration explained above.
      enableRandomness: true

queueTests:
  # 'queueTests.tweets' configures the TweetRunner. The TweetRunner has access to a file containing 500 tweets on
  # Marvel's "Avengers: Endgame" movie. This file is a simplified and shortened version of the original tweet collection,
  # which you can find here: https://www.kaggle.com/datasets/kavita5/twitter-dataset-avengersendgame
  tweets:
    # The TweetRunner will not be run when this is set to 'false'.
    enabled: false
    # The number of goroutines the TweetRunner will spawn to work on queues. (Depending on the configuration of the queue
    # names using the 'append*' properties, this may or may not correspond to a higher number of queues the runner will work on.)
    numQueues: 5
    # If set to 'true', the TweetRunner will append the goroutine index of each of the <numQueues> queues to the latter's names,
    # and consequently each of those goroutines will work on its own queue in Hazelcast. Conversely, if this is set to
    # 'false', all queue goroutines in this particular Hazeltest instance will work on the same queue (which
    # might even be the same as the queue in use by other Hazeltest instances depending on the value for the
    # 'appendClientIdToQueueName' setting).
    # In contrast to map runners such as the PokedexRunner, the TweetRunner cannot distinguish the elements written to and
    # read from a queue by different goroutines due to the nature of a queue (there is no unique key for a value; instead,
    # values or just put and polled). Therefore, different queue goroutines act on each other's elements, and if queue
    # names are identical across Hazeltest instances due to how the two 'append*' properties have been set, the TweetRunners
    # across those instances will act on each other's elements.
    appendQueueIndexToQueueName: true
    # If set to 'true', the TweetRunner will append the unique client ID of this Hazeltest instance to the names of the
    # queue or queues it spawns. This will make sure TweetRunners across Hazeltest instances all work on distinct queues,
    # thus avoiding those runners acting on each other's elements.
    appendClientIdToQueueName: false
    queuePrefix:
      enabled: true
      # This prefix will be put in front of the queue name as it is without introducing any additional special characters.
      prefix: "ht_"
    # Configuration for the goroutine responsible for putting tweets into a Hazelcast queue. Each of the <numQueues>
    # goroutines will spawn one goroutine for performing put operations.
    putConfig:
      # Enable or disable put goroutine.
      enabled: true
      # The number of test loops the goroutine will perform for put operations. In each test loop, the goroutine will put
      # all tweets into a Hazelcast queue. Thus, specifying, for example, 10.000 runs means the goroutine will put
      # 10.000 * 500 tweets in total.
      # You may have noticed the semantics of specifying the number of test loops for this queue runner is different
      # compared to the map runners -- for the latter, one configures the number of test loops only once, and the test loop
      # operations (ingest, read, delete) are performed sequentially. For this queue runner, on the other hand, the queue
      # operations (put and poll) are decoupled in that they run in their own goroutines, so the ability to configure
      # the number of test loops individually for puts and polls directly translates to a higher degree of versatility
      # regarding the client behavior this queue runner can simulate.
      numRuns: 500
      batchSize: 50
      sleeps:
        # Makes a put goroutine sleep once before performing the first put operation.
        initialDelay:
          enabled: false
          durationMs: 2000
          # Enables or disables randomness for this sleep configuration. If enabled and assuming the sleep itself is
          # enabled, the amount of milliseconds to sleep will be determined randomly in the closed interval
          # [0, <durationMs>]. If disabled, on the other hand, the sleep will be static, i.e. the goroutine for this
          # runner will simply sleep for the given amount of milliseconds.
          # Hint: For queue runners, it makes sense to disable randomness for the initial sleep, as a reduced amount of
          # milliseconds slept due to randomness might invalidate the purpose of the initial sleep, which is to give the
          # operation in question, normally the put operation, enough time to put some elements into its queues before
          # the poll operations start.
          enableRandomness: false
        # Causes a put goroutine to sleep after performing one batch of put operations, where the batch size is
        # configured by means of the above '(...).putConfig.batchSize' property.
        betweenActionBatches:
          enabled: true
          durationMs: 1000
          enableRandomness: true
        # Makes a put goroutine pause execution before each run.
        betweenRuns:
          enabled: true
          durationMs: 2000
          enableRandomness: true
    # Configuration for the goroutine running poll operations for tweets against the Hazelcast queue. Just like with the
    # put operations, each of the <numQueues> goroutines will spawn a dedicated goroutine for polling operations, too.
    pollConfig:
      # Enable or disable polling goroutine.
      enabled: true
      numRuns: 500
      batchSize: 50
      # Same as for putConfig
      sleeps:
        initialDelay:
          enabled: true
          durationMs: 12500
          enableRandomness: false
        betweenActionBatches:
          enabled: true
          durationMs: 1000
          enableRandomness: true
        betweenRuns:
          enabled: true
          durationMs: 2000
          enableRandomness: true
  load:
    enabled: false
    numQueues: 10
    # Controls how many entries the queue load runner will use (this property is not available on the tweet runner because
    # the tweet runner works on a static data set, hence the number of elements as well as their size are given). The
    # queue load runner will create <numLoadEntries> string entries to iterate over them for each of the <numQueues> queues
    # in each of the <numRuns> runs of its put and poll configurations.
    numLoadEntries: 5000
    # Configures the size, in bytes, for the random string to be used as each load entry (to reduce Hazeltest's memory
    # footprint, only one random string of size <payloadSizeBytes> is created, and it will serve as the payload for each
    # of the <numLoadEntries> entries)
    payloadSizeBytes: 5000
    appendQueueIndexToQueueName: true
    appendClientIdToQueueName: false
    queuePrefix:
      enabled: true
      prefix: "ht_"
    putConfig:
      enabled: true
      numRuns: 500
      batchSize: 50
      sleeps:
        initialDelay:
          enabled: false
          durationMs: 2000
          enableRandomness: false
        betweenActionBatches:
          enabled: true
          durationMs: 200
          enableRandomness: true
        betweenRuns:
          enabled: true
          durationMs: 200
          enableRandomness: true
    pollConfig:
      enabled: true
      numRuns: 500
      batchSize: 50
      sleeps:
        initialDelay:
          enabled: true
          durationMs: 20000
          enableRandomness: false
        betweenActionBatches:
          enabled: true
          durationMs: 200
          enableRandomness: true
        betweenRuns:
          enabled: true
          durationMs: 200
          enableRandomness: true

# TODO Improve documentation: What datasource does each runner process?
mapTests:
  pokedex:
    # If set to 'false', the PokedexRunner will not be executed
    enabled: true
    # The runner will spawn one goroutine for each map
    numMaps: 5
    # If set to 'true', each of the <numMaps> goroutines will use its own map name, thus effectively accessing its own map
    # In other words, if this is set to 'true', this PokedexRunner will use <numMaps> distinct maps in Hazelcast; if it is set
    # to 'false', the <numMaps> goroutines will access the same map
    # For the PokedexRunner, this will result in a higher number of maps, each containing a smaller number of keys
    # Note: Both the client ID and the currently active goroutine/number are still part of the map keys, so no matter how
    # the following two properties are set, different clients and goroutines within clients will not act on each other's keys
    appendMapIndexToMapName: true
    # If so to 'true', the PokedexRunner will append the ID of its Hazeltest instance to the map name such that it gets its own map in Hazelcast; 
    # if set to 'false', then this PokedexRunner will share its maps with the maps created by PokedexRunners in other Hazeltest instances
    # Set this to 'false' if you would like to make all Hazeltest instances access the same map or maps
    appendClientIdToMapName: false
    # The number of test loops (e.g., ingest-read-delete) to execute in each map goroutine
    numRuns: 10000
    mapPrefix:
      enabled: true
      # The prefix will be put in front of the map name as-is, so no additional underscores or other 
      # characters will be added
      prefix: "ht_"
    # Using sleeps, the pace with which this runner interacts with Hazelcast can be slowed down
    sleeps:
      # Can be enabled to make the test loop sleep for the given duration after each of the <numRuns>. One run consists of three actions (e.g. ingest-read-delete),
      # so use this setting to tell the test loop to sleep after having finished the last action of run <n> and before commencing with the first action of run <n+1>
      betweenRuns:
        enabled: true
        durationMs: 2000
        enableRandomness: true
    testLoop:
      # Can take the value of one of the sub-objects below, i.e. either 'batch' or 'boundary'
      type: boundary
      batch:
        sleeps:
          # Can be enabled to make the batch test loop sleep for the given duration after one batch of actions (e.g., "ingest x elements") has
          # finished, meaning the next action batch will start only after a sleep of <durationMs>
          betweenActionBatches:
            enabled: false
            durationMs: 2000
            enableRandomness: true
      boundary:
        sleeps:
          betweenOperationChains:
            enabled: true
            durationMs: 2000
            enableRandomness: true
          # TODO Sleep between runs?
        operationChain:
          length: 1_000
          resetAfterChain: true
          boundaryDefinition:
            upper:
              mapFillPercentage: 0.8
              enableRandomness: true
            lower:
              mapFillPercentage: 0.2
              enableRandomness: true
            actionTowardsBoundaryProbability: 0.75
  load:
    enabled: false
    numMaps: 2
    # In contrast to the PokedexRunner, whose data set is limited by the number of Pokémon contained in the first-generation Pokédex (151), the LoadRunner can create
    # arbitrarily many entries, and the 'numEntriesPerMap' controls how many entries it will create
    numEntriesPerMap: 5000
    # The payload for each of the <numEntriesPerMap> entries the LoadRunner creates is a random string, whose size in bytes is controlled by the 'payloadSizeBytes' property
    # (that is to say only one random string is created and will be used as the value in each of the <numEntriesPerMap> key-value pairs in order to
    # reduce the application's memory footprint)
    payloadSizeBytes: 100000
    appendMapIndexToMapName: true
    appendClientIdToMapName: false
    numRuns: 10000
    mapPrefix:
      enabled: true
      prefix: "ht_"
    sleeps:
      betweenActionBatches:
        enabled: false
        durationMs: 2000
        enableRandomness: true
      betweenRuns:
        enabled: true
        durationMs: 2000
        enableRandomness: true